<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="icon" type="image/svg" href="icon/d20-black-whitebg.svg">
    <title>Turn Counter</title>
    <style>
        .highlighted {
            background-color: yellow;
        }
        #entries li {
            cursor: pointer;
        }
        .hide {
            display: none;
        }
        body:not(.active-turn) .active-turn-ui {
            display: none;
        }
        .active-turn .no-active-turn-ui {
            display: none;
        }
    </style>
</head>
<body class="no-active-turn">
    <p>Dragon rolled a 19 cultist one rolled and to cultist two rolled 20 Kalar is rolled three anya rolled one whiskers roll an 15 thorn role a negative 11</p>
    <div>
        <input type="text" id="speechInput" placeholder="Use speech-to-text">
        <button onclick="parseAndAddEntries()">Parse</button>
    </div>
    <h2 id="roundCounter" class="round-counter active-turn-ui">Round 1</h2>
    <ul id="entries">
        <!-- will be populated dynamically -->
    </ul>
    <button id="prevTurn" class="previous-turn active-turn-ui" onclick="goBackOneTurn()">Previous Turn</button>
    <button id="nextTurn" class="advance-turn active-turn-ui" onclick="advanceTurn()">Advance Turn</button>
    <button id="startButton" class="no-active-turn-ui" onclick="startTurnCounter()">Start</button>
    <button id="clearAll" class="clear-all active-turn-ui" onclick="clearAll()">Clear All</button>

    <p id="eventlog"></p>

    <script>
        let entries = [];
        let currentTurn = 0;
        let currentRound = 1;
        const numberMap = {
            'zero': 0,
            'one': 1, 'won': 1,
            'two': 2, 'to': 2, 'too': 2,
            'three': 3, 'tree': 3,
            'four': 4, 'fore': 4, 'for': 4,
            'five': 5,
            'six': 6, 'sex': 6,
            'seven': 7,
            'eight': 8, 'ate': 8,
            'nine': 9, 'nigh': 9,
            'ten': 10, 'tin': 10,
            'eleven': 11,
            'twelve': 12,
            'thirteen': 13,
            'fourteen': 14,
            'fifteen': 15,
            'sixteen': 16,
            'seventeen': 17,
            'eighteen': 18,
            'nineteen': 19,
            'twenty': 20,
            'twenty-one': 21, 'twenty-two': 22, 'twenty-three': 23,
            'twenty-four': 24, 'twenty-five': 25, 'twenty-six': 26,
            'twenty-seven': 27, 'twenty-eight': 28, 'twenty-nine': 29,
            'thirty': 30, 'thirty-one': 31, 'thirty-two': 32
        };

        Element.prototype.onClassAdded = function(className, callback) {
            const observer = new MutationObserver(mutations => {
                mutations.forEach(mutation => {
                    if (mutation.type === 'attributes' && mutation.attributeName === 'class') {
                        const oldClassList = mutation.oldValue ? mutation.oldValue.split(/\s+/) : [];
                        const newClassList = this.className.split(/\s+/);
                        if (newClassList.includes(className) && !oldClassList.includes(className)) {
                            callback();
                        }
                    }
                });
            });
            observer.observe(this, { attributes: true, attributeOldValue: true, attributeFilter: ['class'] });
        };

        Element.prototype.onClassRemoved = function(className, callback) {
            const observer = new MutationObserver(mutations => {
                mutations.forEach(mutation => {
                    if (mutation.type === 'attributes' && mutation.attributeName === 'class') {
                        const oldClassList = mutation.oldValue ? mutation.oldValue.split(/\s+/) : [];
                        const newClassList = this.className.split(/\s+/);
                        if (!newClassList.includes(className) && oldClassList.includes(className)) {
                            callback();
                        }
                    }
                });
            });
            observer.observe(this, { attributes: true, attributeOldValue: true, attributeFilter: ['class'] });
        };

        // Usage
        // document.body.onClassAdded('active-turn', function() {
        //     console.log('active-turn was added');
        // });
        // document.body.onClassRemoved('active-turn', function() {
        //     console.log('active-turn was removed');
        // });


        window.onload = function() {
            const savedEntries = getCookie('entries');
            if (savedEntries) {
                entries = JSON.parse(savedEntries);
                renderEntries();
            }

            // rehydrate the current turn, if it was recorded
            const turnStarted = getCookie('turnStarted');
            if (turnStarted) {
                document.body.classList.remove('no-active-turn');
            }
            const savedRound = getCookie('round');
            if (savedRound) {
                currentRound = parseInt(savedRound, 10);
                document.getElementById('roundCounter').textContent = 'Round ' + savedRound;
            }
            const savedTurn = getCookie('turn');
            if (savedTurn) {
                currentTurn = parseInt(savedTurn, 10);
                highlightCurrentTurn();
            }
            
            if (document.getElementById('previousTurn')) document.getElementById('previousTurn').disabled = (currentRound < 2 && currentTurn < 1);
            document.getElementById('prevTurn').disabled = (currentRound < 2 && currentTurn < 1);


            document.getElementById('speechInput').addEventListener('focus', function(e) {
                console.log(e.type);
                document.getElementById('eventlog').textContent = e.type;
                this.select();
            });
            document.getElementById('speechInput').addEventListener('keydown', function(e) {
                console.log(e.type);
                document.getElementById('eventlog').textContent = e.type;
                if (e.key === 'Enter') {
                    parseAndAddEntries();
                }
            });
            document.getElementById('speechInput').addEventListener('input', function(e) {
                console.log(e.type);
                document.getElementById('eventlog').textContent = e.type;
                parseAndAddEntries();
            });

            document.body.onClassAdded('active-turn', function() {
                console.log('active-turn was added');
                document.getElementById('prevTurn').disabled = true;
                document.getElementById('nextTurn').disabled = false;
                document.getElementById('clearAll').disabled = false;
                document.getElementById('startButton').disabled = true;
            });

            document.body.onClassRemoved('active-turn', function() {
                console.log('active-turn was removed');
                document.getElementById('prevTurn').disabled = true;
                document.getElementById('nextTurn').disabled = true;
                document.getElementById('clearAll').disabled = true;
                document.getElementById('startButton').disabled = false;
            });
        };

        function parseAndAddEntries() {
            const input = document.getElementById('speechInput').value + " ";
            let convertedInput = processInput(input, numberMap);

            const regex = /([\w\s]+?)\s*?@ (-?\d+)/g;
            let matches;

            while ((matches = regex.exec(convertedInput)) !== null) {
                let name = matches[1].trim();
                let orderString = matches[2];

                let order;
                if (orderString && isNaN(orderString)) {
                    order = numberMap[orderString.toLowerCase()] || NaN;
                } else if(orderString && !isNaN(orderString)) {
                    order = parseInt(orderString, 10);
                } else {
                    order = NaN;  // default to NaN if orderString is not defined
                }

                // Capitalize the name
                name = name.split(" ").map(capitalize).join(" ");
                entries.push({ name: name, order: order });
            }

            // Sorting and rendering the entries
            entries.sort((a, b) => b.order - a.order);
            renderEntries();
            setCookie('entries', JSON.stringify(entries));
        }

        function processInput(input, numberMap) {
            console.log(input);

            // Remove punctuation
            input = input.replace(/[.,!?;:()]/g, '');

            // Replace the roll/role variations with the symbol "@"
            input = input.replace(/ (rolled|roll|role)( a| an| and)? /g, ' @ ');
            console.log(input);

            // Handle negative numbers in word format adjacent to "@"
            const negativeWordPattern = /@ (?:negative|-) (\w+|\d+)/g;
            input = input.replace(negativeWordPattern, (match, wordOrNum) => {
                if (numberMap[wordOrNum]) {
                    return '@ -' + numberMap[wordOrNum];
                } else {
                    return '@ -' + wordOrNum;
                }
            });
            console.log(input);
            
            // Handle negative numbers in digit format after "@"
            const negativePatternAfter = /@ negative (\d+)/g;
            input = input.replace(negativePatternAfter, (match, p1) => {
                return '@ -' + p1;
            });
            console.log(input);

            // Handle hyphenated numbers adjacent to "rolled" 
            for (const [word, number] of Object.entries(numberMap)) {
                if (!word.includes('-')) continue;

                let patternBefore = new RegExp(`\\b${word}(?= @)`, 'g');
                let patternAfter = new RegExp(`(?<=@ )${word}(?= )`, 'g');
                let patternAfterA = new RegExp(`(?<=@ a )${word}\\b`, 'g');
                let patternAfterAn = new RegExp(`(?<=@ an )${word}\\b`, 'g');
                let patternAfterAnd = new RegExp(`(?<=@ and )${word}\\b`, 'g');

                input = input.replace(patternBefore, `${number}`);
                input = input.replace(patternAfter, `${number}`);
                input = input.replace(patternAfterA, `${number}`);
                input = input.replace(patternAfterAn, `${number}`);
                input = input.replace(patternAfterAnd, `${number}`);
            }
            console.log(input);

            // Then handle non-hyphenated numbers adjacent to "rolled"
            for (const [word, number] of Object.entries(numberMap)) {
                if (word.includes('-')) continue;

                let patternBefore = new RegExp(`\\b${word}(?= @)`, 'g');
                let patternAfter = new RegExp(`(?<=@ )${word}(?= )`, 'g');
                let patternAfterA = new RegExp(`(?<=@ a )${word}\\b`, 'g');
                let patternAfterAn = new RegExp(`(?<=@ an )${word}\\b`, 'g');
                let patternAfterAnd = new RegExp(`(?<=@ and )${word}\\b`, 'g');

                input = input.replace(patternBefore, `${number}`);
                input = input.replace(patternAfter, `${number}`);
                input = input.replace(patternAfterA, `${number}`);
                input = input.replace(patternAfterAn, `${number}`);
                input = input.replace(patternAfterAnd, `${number}`);
            }
            console.log(input);

            return input;
        }

        function capitalize(word) {
            return word.charAt(0).toUpperCase() + word.slice(1).toLowerCase();
        }

        function startTurnCounter() {
            highlightCurrentTurn();
            document.body.classList.add('active-turn');
            setCookie('turnStarted', 'true');
        }

        function advanceTurn() {
            currentTurn = (currentTurn + 1) % entries.length;
            setCookie('turn', currentTurn);

            // If it wraps back to the first player
            if (currentTurn == 0) {
                currentRound++;
                document.getElementById('roundCounter').textContent = 'Round ' + currentRound;
                setCookie('round', currentRound);
            }
            
            highlightCurrentTurn();

            document.getElementById('prevTurn').disabled = false;
        }

        function goBackOneTurn() {
            currentTurn--
            
            // If it wraps back to the last player
            if (currentTurn == -1) {
                currentTurn = entries.length-1
                currentRound--

                // Reset if we went back to "round 0"
                if (currentRound == 0) {
                    currentRound = 1;
                    currentTurn = 0;
                    turnStarted = false;
                    setCookie('turnStarted', 'false');

                }
                document.getElementById('roundCounter').textContent = 'Round ' + currentRound;
                setCookie('round', currentRound)
            }

            highlightCurrentTurn();
            setCookie('turn', currentTurn);

            if (currentRound == 1 && currentTurn == 0) {
                document.getElementById('prevTurn').disabled = true;
            }
        }

        function clearAll() {
            entries = [];
            currentTurn = 0;
            currentRound = 1;
            renderEntries();
            document.body.classList.remove('active-turn');

            // Clearing cookies
            document.cookie = "entries=; expires=Thu, 01 Jan 1970 00:00:00 UTC; path=/;";
            document.cookie = "turn=; expires=Thu, 01 Jan 1970 00:00:00 UTC; path=/;";
            document.cookie = "round=; expires=Thu, 01 Jan 1970 00:00:00 UTC; path=/;";
            document.cookie = "turnStarted=; expires=Thu, 01 Jan 1970 00:00:00 UTC; path=/;";
        }

        function renderEntries() {
            const list = document.getElementById('entries');
            list.innerHTML = '';
            for (let entry of entries) {
                const li = document.createElement('li');
                
                const nameSpan = document.createElement('span');
                nameSpan.textContent = entry.name;
                nameSpan.onclick = function() {
                    makeEditable(nameSpan, entry, 'name');
                };
                
                const orderSpan = document.createElement('span');
                orderSpan.textContent = `(${entry.order})`;
                orderSpan.onclick = function() {
                    makeEditable(orderSpan, entry, 'order', 'number');
                };
                
                li.appendChild(nameSpan);
                li.appendChild(orderSpan);
                list.appendChild(li);
            }
        }


        function makeEditable(element, entry, field, type) {
            const input = document.createElement('input')
            input.type = type
            if (type == 'number') {
                input.setAttribute("pattern", "[0-9]*")
            } else {
                input.setAttribute("autocapitalize", "words")
            }
            input.value = entry[field]
            
            // Handle "submit" when Enter key is pressed
            input.addEventListener('keydown', function(e) {
                if (e.key === 'Enter') {
                    handleEdit();
                }
            });

            // Handle "submit" when input loses focus
            input.addEventListener('focusout', handleEdit);

            function handleEdit() {
                entry[field] = field === 'order' ? parseInt(input.value, 10) : input.value;
                entries.sort((a, b) => b.order - a.order); // Re-sorting on edit
                renderEntries();
                setCookie('entries', JSON.stringify(entries));
            }

            element.replaceWith(input);
            input.select(); 
        }

        function highlightCurrentTurn() {
            const listItems = document.querySelectorAll('#entries li');
            listItems.forEach(li => li.classList.remove('highlighted'));
            if (listItems[currentTurn]) {
                listItems[currentTurn].classList.add('highlighted');
            }
        }

        function setCookie(name, value) {
            document.cookie = `${name}=${value};path=/`;
        }

        function getCookie(name) {
            const value = "; " + document.cookie;
            const parts = value.split("; " + name + "=");
            if (parts.length == 2) return parts.pop().split(";").shift();
        }
    </script>
</body>
</html>
