<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <link rel="icon" type="image/svg" href="icon/d20-black-whitebg.svg">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Architects+Daughter&family=Babylonica&family=Bilbo+Swash+Caps&family=Caveat:wght@400;500;600;700&family=Comforter&family=Condiment&family=Dawning+of+a+New+Day&family=East+Sea+Dokdo&family=Fuggles&family=Grape+Nuts&family=Homemade+Apple&family=Inspiration&family=Julee&family=Just+Me+Again+Down+Here&family=Kolker+Brush&family=La+Belle+Aurore&family=Liu+Jian+Mao+Cao&family=Long+Can&family=Nanum+Brush+Script&family=Nothing+You+Could+Do&family=Oooh+Baby&family=Over+the+Rainbow&family=Permanent+Marker&family=Qwitcher+Grypen:wght@400;700&family=Reenie+Beanie&family=Rock+Salt&family=Ruthie&family=Sassy+Frass&family=Sedgwick+Ave&family=Shalimar&family=Smooch&family=Splash&family=Square+Peg&family=Swanky+and+Moo+Moo&family=Vujahday+Script&family=Waiting+for+the+Sunrise&family=Walter+Turncoat&family=Whisper&display=swap" rel="stylesheet">
    <script src="https://kit.fontawesome.com/d1a29cf881.js" crossorigin="anonymous"></script>
    <title>Initiative Touch</title>
    <style>
        :root {
            --body-color: #bbb;
            --body-bg-image: url(https://foundryvtt.com/static/assets/layout/home-background.webp);
            --div-bg-image: url(data:image/png;base64,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);
            --div-border-color: darkred;
            --button-font: 'East Sea Dokdo';
            --button-text-color: rgba(255,255,255,0.4);
            --button-bg-color: rgba(255,100,0,0.15);
            --button-bg-color--hover: rgba(200,40,0,0.2);
            --button-border-color: rgba(255,255,255,0.1); /*rgba(0,0,0,0.7)*/
            --button-outline-focus: rgba(255,100,0,0.5);
            --mic-color: #8c7f76;
            --input-placeholder-color: #555;
        }
        body {
            margin: 8px;
            background: black var(--body-bg-image) no-repeat;
            background-size: cover;
        }
        button {
            margin: 5px;
            border: 2px solid var(--button-border-color);
            border-radius: 10px;
            font-size: 1.5rem;
            font-family: var(--button-font);
            color: var(--button-text-color);
            background: var(--button-bg-color);
            cursor: pointer;
            transition: background-color 0.15s;
        }
        button:hover,
        button:focus {
            background-color: var(--button-bg-color--hover);
        }
        button:focus-visible {
            outline: 2px var(--button-outline-focus) solid;
        }
        /* header menu */
        .header-menu {
            display: flex;
            justify-content: flex-end;
            height: 50px;
        }
        /* Hide the default arrow of the select box */
        .select-hamburger::-ms-expand {
            display: none;
        }

        .select-hamburger {
            /* Appearance: none will remove the default browser styles */
            -webkit-appearance: none;
            -moz-appearance: none;
            appearance: none;
            text-indent: -9999rem; /* Large negative value */

            /* Set background to Font Awesome hamburger (bars) icon */
            background: url("data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 448 512'><path fill='black' d='M16 132h416c8.837 0 16-7.163 16-16V76c0-8.837-7.163-16-16-16H16C7.163 60 0 67.163 0 76v40c0 8.837 7.163 16 16 16zm0 160h416c8.837 0 16-7.163 16-16v-40c0-8.837-7.163-16-16-16H16c-8.837 0-16 7.163-16 16v40c0 8.837 7.163 16 16 16zm0 160h416c8.837 0 16-7.163 16-16v-40c0-8.837-7.163-16-16-16H16c-8.837 0-16 7.163-16 16v40c0 8.837 7.163 16 16 16z'></path></svg>") no-repeat center center;
            background-size: 25px;
            border: none;
            width: 40px;
            height: 40px;
            cursor: pointer;
            outline: none;
        }
        /* To show a border on focus for accessibility */
        .select-hamburger:focus {
            border: 1px solid #aaa;
            text-indent: initial; /* make text visible again. */
        }
        /* Main wrapper */
        .main {
            display: flex;
            flex-flow: column;
            justify-content: space-between;
            align-items: center;
            box-sizing: border-box;
            margin: 0 auto;
            padding: 5vw;
            border: 1px solid var(--div-border-color);
            width: 90vw;
            height: calc(100vh - 66px);
            max-width: 600px;
            background: #222 var(--div-bg-image) repeat scroll left top;
            color: #bbb;
        }
        /* microphone button */
        #startDictation {
            position:relative;
            display: flex;
            align-items: center;
            justify-content: center;
            margin: auto;
            border-radius:50%;
            font-size: 15vw;
            width: 2em;
            height: 2em;
            color: var(--mic-color);
            background-color:var(--button-bg-color);
            cursor: pointer;
            transition: background-color 0.15s, width 0.5s, height 0.5s, font-size 0.5s;
        }
        #startDictation:hover,
        #startDictation:focus {
            background-color: var(--button-bg-color--hover);
        }
        #startDictation:focus-visible {
            outline: 2px var(--button-outline-focus) solid;
        }
        .players-listed #startDictation {
            margin: 16px auto 0;
            font-size: 5vw;
        }
        input.speech-input {
            display: block;
            opacity: 0.2;
            background: #111;
            color: #ccc;
            font-size: 2em;
            transition: font-size 0.15s;

            /* hide for now */
            opacity: 0 !important;
            height: 0;
            /* end hide */
        }
        input.speech-input:focus {
            /* only show when dictating for now */
            opacity: 1 !important;
            height: auto;
        }
        input.speech-input:last-of-type,
        input.speech-input:focus {
            opacity: 1;
        }
        @media (max-width: 767.9px) {
            input.speech-input:focus {
                position: fixed;
                top: 25%;
                left: 50%;
                width: 100%;
                font-size: 3vw;
                line-height: 20vw;
                text-align: center;
                transform: translateX(-50%);
            }
            input.speech-input:placeholder-shown {
                font-size: 7vw;
            }
        }
        input.speech-input:focus::placeholder {
            color: var(--input-placeholder-color);
        }
        #entries {
            display: none;
            flex: 1;
            padding-left: 0;
            font-size: 2rem;
            list-style: none;
            overflow: auto;
        }
        .players-listed #entries {
            display: flex;
            flex-flow: column;
        }
        #entries li {
            display: flex;
            justify-content: space-between;
            cursor: pointer;
        }
        #entries .player-order {
            margin-left: 1em;
            width: 2em;
            font-size: inherit;
            color: var(--input-placeholder-color);
        }
        #entries .input-editable[type="number"] {
            /* possible number input specific styles */
        }
        #startButton {
            margin-top: auto;
        }
        .highlighted {
            background-color: rgba(255,150,0,0.3);
        }
        .hide {
            display: none;
        }
        body:not(.active-turn) .active-turn-ui {
            display: none;
        }
        .active-turn .no-active-turn-ui {
            display: none;
        }
        body:not(.players-listed) .players-listed-ui {
            display: none;
        }

        /* Font handling */
        .font-architects-daughter { font-family: 'Architects Daughter', cursive; } .font-babylonica { font-family: 'Babylonica', cursive; } .font-bilbo-swash-caps { font-family: 'Bilbo Swash Caps', cursive; } .font-caveat { font-family: 'Caveat', cursive; } .font-comforter { font-family: 'Comforter', cursive; } .font-condiment { font-family: 'Condiment', cursive; } .font-dawning-of-a-new-day { font-family: 'Dawning of a New Day', cursive; } .font-east-sea-dokdo { font-family: 'East Sea Dokdo', cursive; } .font-fuggles { font-family: 'Fuggles', cursive; } .font-grape-nuts { font-family: 'Grape Nuts', cursive; } .font-homemade-apple { font-family: 'Homemade Apple', cursive; } .font-inspiration { font-family: 'Inspiration', cursive; } .font-julee { font-family: 'Julee', cursive; } .font-just-me-again-down-here { font-family: 'Just Me Again Down Here', cursive; } .font-kolker-brush { font-family: 'Kolker Brush', cursive; } .font-la-belle-aurore { font-family: 'La Belle Aurore', cursive; } .font-liu-jian-mao-cao { font-family: 'Liu Jian Mao Cao', cursive; } .font-long-cang { font-family: 'Long Cang', cursive; } .font-nanum-brush-script { font-family: 'Nanum Brush Script', cursive; } .font-nothing-you-could-do { font-family: 'Nothing You Could Do', cursive; } .font-oooh-baby { font-family: 'Oooh Baby', cursive; } .font-over-the-rainbow { font-family: 'Over the Rainbow', cursive; } .font-permanent-marker { font-family: 'Permanent Marker', cursive; } .font-qwitcher-grypen { font-family: 'Qwitcher Grypen', cursive; } .font-reenie-beanie { font-family: 'Reenie Beanie', cursive; } .font-rock-salt { font-family: 'Rock Salt', cursive; } .font-ruthie { font-family: 'Ruthie', cursive; } .font-sassy-frass { font-family: 'Sassy Frass', cursive; } .font-sedgwick-ave { font-family: 'Sedgwick Ave', cursive; } .font-shalimar { font-family: 'Shalimar', cursive; } .font-smooch { font-family: 'Smooch', cursive; } .font-splash { font-family: 'Splash', cursive; } .font-square-peg { font-family: 'Square Peg', cursive; } .font-swanky-and-moo-moo { font-family: 'Swanky and Moo Moo', cursive; } .font-vujahday-script { font-family: 'Vujahday Script', cursive; } .font-waiting-for-the-sunrise { font-family: 'Waiting for the Sunrise', cursive; } .font-walter-turncoat { font-family: 'Walter Turncoat', cursive; } .font-whisper { font-family: 'Whisper', cursive; }
</style>
</head>
<body class="">

    <div class="header-menu">
        <select id="selectFont" class="select-hamburger"></select>
    </div>
    <p style="display:none;">Dragon rolled a 19 cultist one rolled and to cultist two rolled 20 Kalar is rolled three anya rolled one whiskers roll an 15 thorn role a negative 11</p>

    <div class="main">
        <form action="#" style="display:none;"><input id="testInput" type="text" placeholder="test input"/></form>
        <!--<div id="startDictation" class="gn" tabindex="0"><div class="mc"></div></div>-->
        <div id="startDictation">
            <i class="fa-solid fa-microphone"></i>
        </div>
        <form id="speechForm" action="">
            <input id="speechInput" class="speech-input" type="text" placeholder="⇣Dictate with voice key, then press ↵"/>
        </form>
        <h2 id="roundCounter" class="round-counter active-turn-ui">Round 1</h2>
        <ul id="entries">
            <!-- will be populated dynamically -->
        </ul>
        <button id="prevTurn" class="previous-turn active-turn-ui" onclick="goBackOneTurn()">Previous Turn</button>
        <button id="nextTurn" class="advance-turn active-turn-ui" onclick="advanceTurn()">Advance Turn</button>
        <button id="startButton" class="no-active-turn-ui players-listed-ui" onclick="startTurnCounter()">Start</button>
        <button id="clearAll" class="clear-all" onclick="clearAll()">Clear All</button>
    </div>

    <p id="eventlog" style="display: none; color: white;"></p>
    <script>
        let chosenFont;
        let players = [];
        let currentTurn = 0;
        let currentRound = 1;
        const numberMap = {
            'zero': 0,
            'one': 1, 'won': 1,
            'two': 2, 'to': 2, 'too': 2,
            'three': 3, 'tree': 3,
            'four': 4, 'fore': 4, 'for': 4,
            'five': 5,
            'six': 6, 'sex': 6,
            'seven': 7,
            'eight': 8, 'ate': 8,
            'nine': 9, 'nigh': 9,
            'ten': 10, 'tin': 10,
            'eleven': 11,
            'twelve': 12,
            'thirteen': 13,
            'fourteen': 14,
            'fifteen': 15,
            'sixteen': 16,
            'seventeen': 17,
            'eighteen': 18,
            'nineteen': 19,
            'twenty': 20,
            'twenty-one': 21, 'twenty-two': 22, 'twenty-three': 23,
            'twenty-four': 24, 'twenty-five': 25, 'twenty-six': 26,
            'twenty-seven': 27, 'twenty-eight': 28, 'twenty-nine': 29,
            'thirty': 30, 'thirty-one': 31, 'thirty-two': 32
        };

        Element.prototype.onClassAdded = function(className, callback) {
            const observer = new MutationObserver(mutations => {
                mutations.forEach(mutation => {
                    if (mutation.type === 'attributes' && mutation.attributeName === 'class') {
                        const oldClassList = mutation.oldValue ? mutation.oldValue.split(/\s+/) : [];
                        const newClassList = this.className.split(/\s+/);
                        if (newClassList.includes(className) && !oldClassList.includes(className)) {
                            callback();
                        }
                    }
                });
            });
            observer.observe(this, { attributes: true, attributeOldValue: true, attributeFilter: ['class'] });
        };

        Element.prototype.onClassRemoved = function(className, callback) {
            const observer = new MutationObserver(mutations => {
                mutations.forEach(mutation => {
                    if (mutation.type === 'attributes' && mutation.attributeName === 'class') {
                        const oldClassList = mutation.oldValue ? mutation.oldValue.split(/\s+/) : [];
                        const newClassList = this.className.split(/\s+/);
                        if (!newClassList.includes(className) && oldClassList.includes(className)) {
                            callback();
                        }
                    }
                });
            });
            observer.observe(this, { attributes: true, attributeOldValue: true, attributeFilter: ['class'] });
            // Usage
            // document.body.onClassAdded('active-turn', function() {
            //     console.log('active-turn was added');
            // });
            // document.body.onClassRemoved('active-turn', function() {
            //     console.log('active-turn was removed');
            // });
        };



        window.onload = function() {
            chosenFont = getCookie('fontPreference') || 'font-nothing-you-could-do'
            setCookie('fontPreference', chosenFont);
            document.body.classList.add(chosenFont);
            populateSelectWithFonts();
            document.querySelector('#selectFont').addEventListener('change', function(event) {
                const selectedClass = event.target.value;
                // First, remove any existing font class from the body
                document.body.classList.remove(...document.body.classList);
                // Then, add the new selected class
                document.body.classList.add(selectedClass);
                // Remember the setting
                setCookie('fontPreference', selectedClass);
            })

            // Recall player entries saved to cookie
            const savedEntries = getCookie('players');
            if (savedEntries) {
                players = JSON.parse(savedEntries);
                renderPlayers();
            }

            // rehydrate the current turn, if it was recorded
            const turnStarted = getCookie('turnStarted');
            if (turnStarted) {
                document.body.classList.add('active-turn');
            }
            const savedRound = getCookie('round');
            if (savedRound) {
                currentRound = parseInt(savedRound, 10);
                document.getElementById('roundCounter').textContent = 'Round ' + savedRound;
            }
            const savedTurn = getCookie('turn');
            if (savedTurn) {
                currentTurn = parseInt(savedTurn, 10);
                highlightCurrentTurn();
            }
            
            // set the state of the Previous buttton based on rehydrated round/turn state
            document.getElementById('prevTurn').disabled = (currentRound < 2 && currentTurn < 1);

            document.getElementById('startDictation').addEventListener('click', function() {
                // SYMBOLS: ⇣ ↵
                document.getElementById('speechInput').focus()
            });


            // SPEECH INPUT HANDLING ==========================================


            // // Example event delegation: Attach listeners to the speechInputs container and delegate to children
            // document.getElementById('speechInputs').addEventListener('focus', function(e) {
            //     if (e.target && e.target.classList.contains('speech-input')) {
            //         console.log(e.type)
            //         document.getElementById('eventlog').textContent = e.type;
            //     }
            // })

            // let lastEntryWasKeyboard = false;

            document.getElementById('speechInput').addEventListener('focus', function(e) {
                logEvent(e)
                // this.select()
            })
            document.getElementById('speechInput').addEventListener('focusout', function(e) {
                logEvent(e)
                // if (!lastEntryWasKeyboard) {
                //     parseAndAddEntries()
                //     setTimeout(()=>{document.getElementById('startButton').focus()}, 1)
                // } else {
                //     lastEntryWasKeyboard = false
                // }
                parseAndAddEntries()
            })

            // Submit handler
            document.getElementById("speechForm").parentElement.addEventListener('submit', function(e) {
                e.preventDefault()
                logEvent(e)
                parseAndAddEntries()
                setTimeout(()=>{document.getElementById('startButton').focus()}, 1)
            })

            const events = ['input', 'change', 'keydown', 'focus', 'focusin', 'focusout', 'blur', 'beforeinput', 'compositionstart', 'compositionupdate', 'compositionend', 'select', 'paste', 'copy', 'submit'];
            events.forEach(function(event) {
                document.getElementById("testInput").addEventListener(event, function(e) {
                    logEvent(e)
                })
            })

            function logEvent (e) {
                console.log(e.type)
                document.getElementById('eventlog').innerHTML += ('<br/>' + e.type + (e.type == 'keydown' ? ' '+e.which : ''))
            }

            // document.getElementById('speechInput').addEventListener('keydown', function(e) {
            //     console.log(e.type)
            //     if (e.key === 'Enter') {
            //         parseAndAddEntries()
            //         setTimeout(()=>{document.getElementById('startButton').focus()}, 1)
            //     // } else {
            //     //     lastEntryWasKeyboard = true
            //     }
            // })

            document.body.onClassAdded('active-turn', function() {
                console.log('active-turn was added');
                document.getElementById('prevTurn').disabled = true;
                document.getElementById('nextTurn').disabled = false;
                document.getElementById('startButton').disabled = true;
            });

            document.body.onClassRemoved('active-turn', function() {
                console.log('active-turn was removed');
                document.getElementById('prevTurn').disabled = true;
                document.getElementById('nextTurn').disabled = true;
                document.getElementById('startButton').disabled = false;
            });
        };
        function populateSelectWithFonts() {
            const fonts = [
                'Architects Daughter', 'Babylonica', 'Bilbo Swash Caps', 'Caveat', 'Comforter', 
                'Condiment', 'Dawning of a New Day', 'East Sea Dokdo', 'Fuggles',
                'Grape Nuts', 'Homemade Apple', 'Inspiration', 'Julee', 'Just Me Again Down Here', 'Kolker Brush',
                'La Belle Aurore', 'Liu Jian Mao Cao', 'Long Cang', 'Nanum Brush Script', 
                'Nothing You Could Do', 'Oooh Baby', 'Over the Rainbow', 'Permanent Marker', 'Qwitcher Grypen', 'Reenie Beanie', 
                'Rock Salt', 'Ruthie', 'Sassy Frass', 'Sedgwick Ave', 'Shalimar', 'Smooch', 'Splash', 'Square Peg',
                'Swanky and Moo Moo', 'Vujahday Script', 'Waiting for the Sunrise', 'Walter Turncoat', 'Whisper'
            ];

            const selectElement = document.querySelector('#selectFont');
            fonts.forEach(font => {
                const option = document.createElement('option');
                const val = 'font-' + font.toLowerCase().replace(/\s+/g, '-'); // Convert font name to classname format
                option.value = val;
                if (val == chosenFont) {
                    option.selected = true
                }
                option.textContent = font;
                selectElement.appendChild(option);
            });
        }

        function parseAndAddEntries() {
            // Get all input elements with the class 'speech-input'
            const prompts = document.querySelectorAll('.speech-input');
            
            // Map over each input to get its value and join them with spaces
            const joinedInput = Array.from(prompts).map(prompt => prompt.value).join(' ') + ' ';

            let convertedInput = processInput(joinedInput, numberMap);

            const regex = /([\w\s]+?)\s*?@ (-?\d+)/g;
            let matches;

            players = [];
            while ((matches = regex.exec(convertedInput)) !== null) {
                let name = matches[1].trim();
                let orderString = matches[2];

                let order;
                if (orderString && isNaN(orderString)) {
                    order = numberMap[orderString.toLowerCase()] || NaN;
                } else if(orderString && !isNaN(orderString)) {
                    order = parseInt(orderString, 10);
                } else {
                    order = NaN;  // default to NaN if orderString is not defined
                }

                // Capitalize the name
                name = name.split(" ").map(capitalize).join(" ");
                players.push({ name: name, order: order });
            }

            // Sorting and rendering the players
            players.sort((a, b) => b.order - a.order);
            renderPlayers();
            setCookie('players', JSON.stringify(players));
        }

        function processInput(input, numberMap) {
            console.log(input);

            // Remove punctuation
            input = input.replace(/[.,!?;:()]/g, '');

            // Replace the roll/role variations with the symbol "@"
            input = input.replace(/ (rolled|rolls|roll|roles|role|roads|road)( a| an| and| of| on)? /g, ' @ ');
            console.log(input);

            // Handle negative numbers in word format adjacent to "@"
            const negativeWordPattern = /@ (?:negative|-) (\w+|\d+)/g;
            input = input.replace(negativeWordPattern, (match, wordOrNum) => {
                if (numberMap[wordOrNum]) {
                    return '@ -' + numberMap[wordOrNum];
                } else {
                    return '@ -' + wordOrNum;
                }
            });
            console.log(input);
            
            // Handle negative numbers in digit format after "@"
            const negativePatternAfter = /@ negative (\d+)/g;
            input = input.replace(negativePatternAfter, (match, p1) => {
                return '@ -' + p1;
            });
            console.log(input);

            // Handle hyphenated numbers adjacent to "rolled" 
            for (const [word, number] of Object.entries(numberMap)) {
                if (!word.includes('-')) continue;

                let patternBefore = new RegExp(`\\b${word}(?= @)`, 'g');
                let patternAfter = new RegExp(`(?<=@ )${word}(?= )`, 'g');
                let patternAfterA = new RegExp(`(?<=@ a )${word}\\b`, 'g');
                let patternAfterAn = new RegExp(`(?<=@ an )${word}\\b`, 'g');
                let patternAfterAnd = new RegExp(`(?<=@ and )${word}\\b`, 'g');

                input = input.replace(patternBefore, `${number}`);
                input = input.replace(patternAfter, `${number}`);
                input = input.replace(patternAfterA, `${number}`);
                input = input.replace(patternAfterAn, `${number}`);
                input = input.replace(patternAfterAnd, `${number}`);
            }
            console.log(input);

            // Then handle non-hyphenated numbers adjacent to "rolled"
            for (const [word, number] of Object.entries(numberMap)) {
                if (word.includes('-')) continue;

                let patternBefore = new RegExp(`\\b${word}(?= @)`, 'g');
                let patternAfter = new RegExp(`(?<=@ )${word}(?= )`, 'g');
                let patternAfterA = new RegExp(`(?<=@ a )${word}\\b`, 'g');
                let patternAfterAn = new RegExp(`(?<=@ an )${word}\\b`, 'g');
                let patternAfterAnd = new RegExp(`(?<=@ and )${word}\\b`, 'g');

                input = input.replace(patternBefore, `${number}`);
                input = input.replace(patternAfter, `${number}`);
                input = input.replace(patternAfterA, `${number}`);
                input = input.replace(patternAfterAn, `${number}`);
                input = input.replace(patternAfterAnd, `${number}`);
            }
            console.log(input);

            return input;
        }

        function capitalize(word) {
            return word.charAt(0).toUpperCase() + word.slice(1).toLowerCase();
        }

        function startTurnCounter() {
            highlightCurrentTurn();
            document.body.classList.add('active-turn');
            setCookie('turnStarted', 'true');
        }

        function advanceTurn() {
            currentTurn = (currentTurn + 1) % players.length;
            setCookie('turn', currentTurn);

            // If it wraps back to the first player
            if (currentTurn == 0) {
                currentRound++;
                document.getElementById('roundCounter').textContent = 'Round ' + currentRound;
                setCookie('round', currentRound);
            }
            
            highlightCurrentTurn();

            document.getElementById('prevTurn').disabled = false;
        }

        function goBackOneTurn() {
            currentTurn--
            
            // If it wraps back to the last player
            if (currentTurn == -1) {
                currentTurn = players.length-1
                currentRound--

                // Reset if we went back to "round 0"
                if (currentRound == 0) {
                    currentRound = 1;
                    currentTurn = 0;
                    turnStarted = false;
                    setCookie('turnStarted', 'false');

                }
                document.getElementById('roundCounter').textContent = 'Round ' + currentRound;
                setCookie('round', currentRound)
            }

            highlightCurrentTurn();
            setCookie('turn', currentTurn);

            if (currentRound == 1 && currentTurn == 0) {
                document.getElementById('prevTurn').disabled = true;
            }
        }

        function clearAll() {
            players = [];
            currentTurn = 0;
            currentRound = 1;
            renderPlayers();
            document.body.classList.remove('active-turn');
            document.body.classList.remove('players-listed');
            document.getElementById('speechInput').value = '';

            // Clearing cookies
            document.cookie = "players=; expires=Thu, 01 Jan 1970 00:00:00 UTC; path=/;";
            document.cookie = "turn=; expires=Thu, 01 Jan 1970 00:00:00 UTC; path=/;";
            document.cookie = "round=; expires=Thu, 01 Jan 1970 00:00:00 UTC; path=/;";
            document.cookie = "turnStarted=; expires=Thu, 01 Jan 1970 00:00:00 UTC; path=/;";
            document.cookie = "fontPreference=; expires=Thu, 01 Jan 1970 00:00:00 UTC; path=/;";
        }

        function renderPlayers() {
            const list = document.getElementById('entries');
            list.innerHTML = '';
            for (let entry of players) {
                const li = document.createElement('li');
                
                const nameSpan = document.createElement('span');
                nameSpan.className = 'player-name';
                nameSpan.setAttribute('tabindex', '0');
                nameSpan.textContent = entry.name;
                nameSpan.onclick = function() {
                    makeEditable(nameSpan, entry, 'name', 'text');
                };
                nameSpan.onfocus = function() {
                    makeEditable(nameSpan, entry, 'name', 'text');
                };
                
                const orderSpan = document.createElement('span')
                orderSpan.textContent = `${entry.order}`
                orderSpan.className = 'player-order';
                orderSpan.setAttribute('tabindex', '0')
                orderSpan.onfocus = function() {
                    makeEditable(orderSpan, entry, 'order', 'number')
                };
                orderSpan.onclick = function() {
                    makeEditable(orderSpan, entry, 'order', 'number')
                };
                
                li.appendChild(nameSpan);
                li.appendChild(orderSpan);
                list.appendChild(li);
            }
            document.body.classList.add('players-listed');
        }


        function makeEditable(element, entry, field, type) {
            const input = document.createElement('input')
            input.className = 'input-editable player-order';
            input.type = type
            if (type == 'number') {
                input.setAttribute("pattern", "[0-9]*")
            } else {
                input.setAttribute("autocapitalize", "words")
            }
            input.value = entry[field]
            
            // Handle "submit" when Enter key is pressed
            input.addEventListener('keydown', function(e) {
                if (e.key === 'Enter') {
                    handleEdit();
                }
            });

            // Handle "submit" when input loses focus
            input.addEventListener('focusout', handleEdit);

            function handleEdit() {
                entry[field] = field === 'order' ? parseInt(input.value, 10) : input.value;
                players.sort((a, b) => b.order - a.order); // Re-sorting on edit
                renderPlayers();
                setCookie('players', JSON.stringify(players));
            }

            element.replaceWith(input);
            input.select(); 
        }

        function highlightCurrentTurn() {
            const listItems = document.querySelectorAll('#entries li');
            listItems.forEach(li => li.classList.remove('highlighted'));
            if (listItems[currentTurn]) {
                listItems[currentTurn].classList.add('highlighted');
            }
        }

        function setCookie(name, value) {
            document.cookie = `${name}=${value};path=/`;
        }

        function getCookie(name) {
            const value = "; " + document.cookie;
            const parts = value.split("; " + name + "=");
            if (parts.length == 2) return parts.pop().split(";").shift();
        }
    </script>
    <!--
        TODOs
        1. if the parser doesn't detect any player entries from the input string, then do not go into "players-listed" mode.
        2. add other commands to the dicatation input
        3. save the previous 'speechInput values somewhere in a class="speech-input" hidden input or div. maybe remove portions of the string that didn't parse into entries. (might require a rework of the whole parsing system though, like splitting everything by ' ' and then manipulating a big ol array.)
        4. make subsequent dictations (or "prompts") add more players to the list, instead of replacing. But clear the 'speechInput' field
    -->
</body>
</html>
