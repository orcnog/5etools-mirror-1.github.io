<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Turn Counter</title>
    <style>
        .highlighted {
            background-color: yellow;
        }
        #entries li {
            cursor: pointer;
        }
    </style>
</head>
<body>
    <p>Dragon rolled a 19 cultist one rolled and to cultist two rolled 20 Kalar is rolled three anya rolled one whiskers roll an 15 thorn role a negative 11</p>
    <div>
        <input type="text" id="speechInput" placeholder="Use speech-to-text">
        <button onclick="parseAndAddEntries()">Parse</button>
    </div>
    <ul id="entries"></ul>
    <button onclick="startTurnCounter()">Go</button>

    <script>
        let entries = [];
        let currentTurn = 0;
        const numberMap = {
            'zero': 0,
            'one': 1, 'won': 1,
            'two': 2, 'to': 2, 'too': 2,
            'three': 3, 'tree': 3,
            'four': 4, 'fore': 4, 'for': 4,
            'five': 5,
            'six': 6, 'sex': 6,
            'seven': 7,
            'eight': 8, 'ate': 8,
            'nine': 9, 'nigh': 9,
            'ten': 10, 'tin': 10,
            'eleven': 11,
            'twelve': 12,
            'thirteen': 13,
            'fourteen': 14,
            'fifteen': 15,
            'sixteen': 16,
            'seventeen': 17,
            'eighteen': 18,
            'nineteen': 19,
            'twenty': 20,
            'twenty-one': 21, 'twenty-two': 22, 'twenty-three': 23,
            'twenty-four': 24, 'twenty-five': 25, 'twenty-six': 26,
            'twenty-seven': 27, 'twenty-eight': 28, 'twenty-nine': 29,
            'thirty': 30, 'thirty-one': 31, 'thirty-two': 32
        };

        window.onload = function() {
            const savedEntries = getCookie('entries');
            if (savedEntries) {
                entries = JSON.parse(savedEntries);
                renderEntries();
            }

            const savedTurn = getCookie('turn');
            if (savedTurn) {
                currentTurn = parseInt(savedTurn, 10);
                highlightCurrentTurn();
            }
        };

        function parseAndAddEntries() {
            const input = document.getElementById('speechInput').value + " ";
            let convertedInput = processInput(input, numberMap);

            const regex = /([\w\s]+?)\s*?@ (-?\d+)/g;
            let matches;

            while ((matches = regex.exec(convertedInput)) !== null) {
                let name = matches[1].trim();
                let orderString = matches[2];

                let order;
                if (orderString && isNaN(orderString)) {
                    order = numberMap[orderString.toLowerCase()] || NaN;
                } else if(orderString && !isNaN(orderString)) {
                    order = parseInt(orderString, 10);
                } else {
                    order = NaN;  // default to NaN if orderString is not defined
                }

                // Capitalize the name
                name = name.split(" ").map(capitalize).join(" ");
                entries.push({ name: name, order: order });
            }

            // Sorting and rendering the entries
            entries.sort((a, b) => b.order - a.order);
            renderEntries();
        }

        function processInput(input, numberMap) {
            console.log(input);

            // Remove punctuation
            input = input.replace(/[.,!?;:()]/g, '');

            // Replace the roll/role variations with the symbol "@"
            input = input.replace(/ (rolled|roll|role)( a| an| and)? /g, ' @ ');
            console.log(input);

            // Handle negative numbers in word format adjacent to "@"
            const negativeWordPattern = /@ (?:negative|-) (\w+|\d+)/g;
            input = input.replace(negativeWordPattern, (match, wordOrNum) => {
                if (numberMap[wordOrNum]) {
                    return '@ -' + numberMap[wordOrNum];
                } else {
                    return '@ -' + wordOrNum;
                }
            });
            console.log(input);
            
            // Handle negative numbers in digit format after "@"
            const negativePatternAfter = /@ negative (\d+)/g;
            input = input.replace(negativePatternAfter, (match, p1) => {
                return '@ -' + p1;
            });
            console.log(input);

            // Handle hyphenated numbers adjacent to "rolled" 
            for (const [word, number] of Object.entries(numberMap)) {
                if (!word.includes('-')) continue;

                let patternBefore = new RegExp(`\\b${word}(?= @)`, 'g');
                let patternAfter = new RegExp(`(?<=@ )${word}(?= )`, 'g');
                let patternAfterA = new RegExp(`(?<=@ a )${word}\\b`, 'g');
                let patternAfterAn = new RegExp(`(?<=@ an )${word}\\b`, 'g');
                let patternAfterAnd = new RegExp(`(?<=@ and )${word}\\b`, 'g');

                input = input.replace(patternBefore, `${number}`);
                input = input.replace(patternAfter, `${number}`);
                input = input.replace(patternAfterA, `${number}`);
                input = input.replace(patternAfterAn, `${number}`);
                input = input.replace(patternAfterAnd, `${number}`);
            }
            console.log(input);

            // Then handle non-hyphenated numbers adjacent to "rolled"
            for (const [word, number] of Object.entries(numberMap)) {
                if (word.includes('-')) continue;

                let patternBefore = new RegExp(`\\b${word}(?= @)`, 'g');
                let patternAfter = new RegExp(`(?<=@ )${word}(?= )`, 'g');
                let patternAfterA = new RegExp(`(?<=@ a )${word}\\b`, 'g');
                let patternAfterAn = new RegExp(`(?<=@ an )${word}\\b`, 'g');
                let patternAfterAnd = new RegExp(`(?<=@ and )${word}\\b`, 'g');

                input = input.replace(patternBefore, `${number}`);
                input = input.replace(patternAfter, `${number}`);
                input = input.replace(patternAfterA, `${number}`);
                input = input.replace(patternAfterAn, `${number}`);
                input = input.replace(patternAfterAnd, `${number}`);
            }
            console.log(input);

            return input;
        }

        function capitalize(word) {
            return word.charAt(0).toUpperCase() + word.slice(1).toLowerCase();
        }

        function startTurnCounter() {
            highlightCurrentTurn();
            document.getElementById('goButton').disabled = true;
        }

        function advanceTurn() {
            currentTurn = (currentTurn + 1) % entries.length;
            setCookie('turn', currentTurn);
            highlightCurrentTurn();
        }

        function renderEntries() {
            const list = document.getElementById('entries');
            list.innerHTML = '';
            for (let entry of entries) {
                const li = document.createElement('li');
                
                const span = document.createElement('span');
                span.textContent = `${entry.name} (${entry.order})`;
                span.onclick = function() {
                    makeEditable(span, entry);
                };
                
                li.appendChild(span);
                list.appendChild(li);
            }
            const advanceButton = document.createElement('button');
            advanceButton.textContent = 'Advance Turn';
            advanceButton.onclick = advanceTurn;
            list.appendChild(advanceButton);
        }

        function makeEditable(element, entry) {
            const input = document.createElement('input');
            input.value = entry.name;
            input.onblur = function() {
                entry.name = input.value;
                renderEntries();
                setCookie('entries', JSON.stringify(entries));
            };
            element.replaceWith(input);
            input.select(); 
        }

        function highlightCurrentTurn() {
            const listItems = document.querySelectorAll('#entries li');
            listItems.forEach(li => li.classList.remove('highlighted'));
            if (listItems[currentTurn]) {
                listItems[currentTurn].classList.add('highlighted');
            }
        }

        function setCookie(name, value) {
            document.cookie = `${name}=${value};path=/`;
        }

        function getCookie(name) {
            const value = "; " + document.cookie;
            const parts = value.split("; " + name + "=");
            if (parts.length == 2) return parts.pop().split(";").shift();
        }
    </script>
</body>
</html>
