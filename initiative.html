<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="icon" type="image/svg" href="icon/d20-black-whitebg.svg">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Architects+Daughter&family=Babylonica&family=Bilbo+Swash+Caps&family=Caveat:wght@400;500;600;700&family=Comforter&family=Condiment&family=Dawning+of+a+New+Day&family=East+Sea+Dokdo&family=Fuggles&family=Grape+Nuts&family=Homemade+Apple&family=Inspiration&family=Julee&family=Just+Me+Again+Down+Here&family=Kolker+Brush&family=La+Belle+Aurore&family=Liu+Jian+Mao+Cao&family=Long+Can&family=Nanum+Brush+Script&family=Nothing+You+Could+Do&family=Oooh+Baby&family=Over+the+Rainbow&family=Permanent+Marker&family=Qwitcher+Grypen:wght@400;700&family=Reenie+Beanie&family=Rock+Salt&family=Ruthie&family=Sassy+Frass&family=Sedgwick+Ave&family=Shalimar&family=Smooch&family=Splash&family=Square+Peg&family=Swanky+and+Moo+Moo&family=Vujahday+Script&family=Waiting+for+the+Sunrise&family=Walter+Turncoat&family=Whisper&display=swap" rel="stylesheet">
    <title>Turn Counter</title>
    <style>
        :root {
            --body-color: #bbb;
            --body-bg-image: url(https://foundryvtt.com/static/assets/layout/home-background.webp);
            --div-bg-image: url(data:image/png;base64,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);
            --div-border-color: darkred;
            --button-font: 'East Sea Dokdo';
            --button-text-color: rgba(255,255,255,0.4);
            --button-bg-color: rgba(255,100,0,0.15);
            --button-bg-color--hover: rgba(200,40,0,0.2);
            --button-border-color: rgba(255,255,255,0.1); /*rgba(0,0,0,0.7)*/
            --button-outline-focus: rgba(255,100,0,0.5);
            --mic-color: #8c7f76;
        }
        body {
            height: 101vh;
            background: black var(--body-bg-image) no-repeat;
            background-size: cover;
        }
        .main {
            display: flex;
            flex-flow: column;
            justify-content: space-between;
            align-items: center;
            box-sizing: border-box;
            margin: 0 auto;
            padding: 5vw;
            border: 1px solid var(--div-border-color);
            width: 90vw;
            max-width: 500px;
            background: #222 var(--div-bg-image) repeat scroll left top;
            color: #bbb;
        }
        button {
            margin: 5px;
            border: 2px solid var(--button-border-color);
            border-radius: 10px;
            font-size: 1.5rem;
            font-family: var(--button-font);
            color: var(--button-text-color);
            background: var(--button-bg-color);
            cursor: pointer;
            transition: background-color 0.15s;
        }
        button:hover,
        button:focus {
            background-color: var(--button-bg-color--hover);
        }
        button:focus-visible {
            outline: 2px var(--button-outline-focus) solid;
        }
        .gn{
            position:relative;
            margin: 32px auto 0;
            border-radius:50%;
            width:10em;
            height:10em;
            background-color:var(--button-bg-color);
            cursor: pointer;
            transition: background-color 0.15s, width 0.5s, height 0.5s;
        }
        .gn:hover,
        .gn:focus {
            background-color: var(--button-bg-color--hover);
        }
        .gn:focus-visible {
            outline: 2px var(--button-outline-focus) solid;
        }
        .players-listed .gn {
            width: 5em;
            height: 5em;
        }
        .gn:before, .gn:after, .mc:before, .mc:after {
            content:'';
            position:absolute;
            background-color:var(--mic-color);
        }
        .gn:after{
            top:30%; left:43%;
            height:15%; width:14%;
            border-top-left-radius:50%;
            border-top-right-radius:50%;
        }
        .gn:before{
            top:40%; left:43%;
            height:15%; width:14%;
            border-bottom-left-radius:50%;
            border-bottom-right-radius:50%;
        }
        .mc{
            position:absolute;
            top:50%; left:37%;
            height:24%;
            width: 26%;
            font-size: 85%;
            overflow:hidden;
        }
        .mc:before{
            bottom:50%;
            width:100%; height:100%;
            box-sizing:border-box;
            border-radius:50%;
            border:0.5em solid var(--mic-color);
            background:none;
        }
        .mc:after{
            top:50%; left:40%;
            width:20%; height:25%;
        }
        input.speech-input {
            display: block;
            opacity: 0.2;
            background: #111;
            color: #ccc;
            font-size: 2em;
            transition: font-size 0.15s;

            /* hide for now */
            opacity: 0 !important;
            height: 0;
            /* end hide */
        }
        input.speech-input:focus {
            /* only show when dictating for now */
            opacity: 1 !important;
            height: auto;
        }
        input.speech-input:last-of-type,
        input.speech-input:focus {
            opacity: 1;
        }
        @media (max-width: 767.9px) {
            input.speech-input:focus {
                position: fixed;
                top: 25%;
                left: 50%;
                width: 100%;
                font-size: 3vw;
                line-height: 20vw;
                text-align: center;
                transform: translateX(-50%);
            }
            input.speech-input:placeholder-shown {
                font-size: 7vw;
            }
        }
        input.speech-input:focus::placeholder {
            color: #555;
        }
        #entries {
            font-size: 2rem;
            list-style: none;
            padding-left: 0;
        }
        #entries li {
            display: flex;
            justify-content: space-between;
            cursor: pointer;
        }
        #entries span:last-of-type {
            padding-left: 1em;
        }
        .highlighted {
            background-color: rgba(255,150,0,0.3);
        }
        .hide {
            display: none;
        }
        body:not(.active-turn) .active-turn-ui {
            display: none;
        }
        .active-turn .no-active-turn-ui {
            display: none;
        }
        body:not(.players-listed) .players-listed-ui {
            display: none;
        }

        /* Font handling */
        .font-architects-daughter { font-family: 'Architects Daughter', cursive; } .font-babylonica { font-family: 'Babylonica', cursive; } .font-bilbo-swash-caps { font-family: 'Bilbo Swash Caps', cursive; } .font-caveat { font-family: 'Caveat', cursive; } .font-comforter { font-family: 'Comforter', cursive; } .font-condiment { font-family: 'Condiment', cursive; } .font-dawning-of-a-new-day { font-family: 'Dawning of a New Day', cursive; } .font-east-sea-dokdo { font-family: 'East Sea Dokdo', cursive; } .font-fuggles { font-family: 'Fuggles', cursive; } .font-grape-nuts { font-family: 'Grape Nuts', cursive; } .font-homemade-apple { font-family: 'Homemade Apple', cursive; } .font-inspiration { font-family: 'Inspiration', cursive; } .font-julee { font-family: 'Julee', cursive; } .font-just-me-again-down-here { font-family: 'Just Me Again Down Here', cursive; } .font-kolker-brush { font-family: 'Kolker Brush', cursive; } .font-la-belle-aurore { font-family: 'La Belle Aurore', cursive; } .font-liu-jian-mao-cao { font-family: 'Liu Jian Mao Cao', cursive; } .font-long-cang { font-family: 'Long Cang', cursive; } .font-nanum-brush-script { font-family: 'Nanum Brush Script', cursive; } .font-nothing-you-could-do { font-family: 'Nothing You Could Do', cursive; } .font-oooh-baby { font-family: 'Oooh Baby', cursive; } .font-over-the-rainbow { font-family: 'Over the Rainbow', cursive; } .font-permanent-marker { font-family: 'Permanent Marker', cursive; } .font-qwitcher-grypen { font-family: 'Qwitcher Grypen', cursive; } .font-reenie-beanie { font-family: 'Reenie Beanie', cursive; } .font-rock-salt { font-family: 'Rock Salt', cursive; } .font-ruthie { font-family: 'Ruthie', cursive; } .font-sassy-frass { font-family: 'Sassy Frass', cursive; } .font-sedgwick-ave { font-family: 'Sedgwick Ave', cursive; } .font-shalimar { font-family: 'Shalimar', cursive; } .font-smooch { font-family: 'Smooch', cursive; } .font-splash { font-family: 'Splash', cursive; } .font-square-peg { font-family: 'Square Peg', cursive; } .font-swanky-and-moo-moo { font-family: 'Swanky and Moo Moo', cursive; } .font-vujahday-script { font-family: 'Vujahday Script', cursive; } .font-waiting-for-the-sunrise { font-family: 'Waiting for the Sunrise', cursive; } .font-walter-turncoat { font-family: 'Walter Turncoat', cursive; } .font-whisper { font-family: 'Whisper', cursive; }
</style>
</head>
<body class="">

    <div class="header-menu">
        <select id="selectFont"></select>
    </div>
    <p>Dragon rolled a 19 cultist one rolled and to cultist two rolled 20 Kalar is rolled three anya rolled one whiskers roll an 15 thorn role a negative 11</p>

    <div class="main">
        <div id="startDictation" class="gn" tabindex="0"><div class="mc"></div></div>
        <div id="speechInputs">
            <!-- will be populated dynamically -->
        </div>
        <h2 id="roundCounter" class="round-counter active-turn-ui">Round 1</h2>
        <ul id="entries">
            <!-- will be populated dynamically -->
        </ul>
        <button id="prevTurn" class="previous-turn active-turn-ui" onclick="goBackOneTurn()">Previous Turn</button>
        <button id="nextTurn" class="advance-turn active-turn-ui" onclick="advanceTurn()">Advance Turn</button>
        <button id="startButton" class="no-active-turn-ui players-listed-ui" onclick="startTurnCounter()">Start</button>
        <button id="clearAll" class="clear-all" onclick="clearAll()">Clear All</button>
    </div>

    <script>
        let chosenFont;
        let players = [];
        let currentTurn = 0;
        let currentRound = 1;
        const numberMap = {
            'zero': 0,
            'one': 1, 'won': 1,
            'two': 2, 'to': 2, 'too': 2,
            'three': 3, 'tree': 3,
            'four': 4, 'fore': 4, 'for': 4,
            'five': 5,
            'six': 6, 'sex': 6,
            'seven': 7,
            'eight': 8, 'ate': 8,
            'nine': 9, 'nigh': 9,
            'ten': 10, 'tin': 10,
            'eleven': 11,
            'twelve': 12,
            'thirteen': 13,
            'fourteen': 14,
            'fifteen': 15,
            'sixteen': 16,
            'seventeen': 17,
            'eighteen': 18,
            'nineteen': 19,
            'twenty': 20,
            'twenty-one': 21, 'twenty-two': 22, 'twenty-three': 23,
            'twenty-four': 24, 'twenty-five': 25, 'twenty-six': 26,
            'twenty-seven': 27, 'twenty-eight': 28, 'twenty-nine': 29,
            'thirty': 30, 'thirty-one': 31, 'thirty-two': 32
        };

        Element.prototype.onClassAdded = function(className, callback) {
            const observer = new MutationObserver(mutations => {
                mutations.forEach(mutation => {
                    if (mutation.type === 'attributes' && mutation.attributeName === 'class') {
                        const oldClassList = mutation.oldValue ? mutation.oldValue.split(/\s+/) : [];
                        const newClassList = this.className.split(/\s+/);
                        if (newClassList.includes(className) && !oldClassList.includes(className)) {
                            callback();
                        }
                    }
                });
            });
            observer.observe(this, { attributes: true, attributeOldValue: true, attributeFilter: ['class'] });
        };

        Element.prototype.onClassRemoved = function(className, callback) {
            const observer = new MutationObserver(mutations => {
                mutations.forEach(mutation => {
                    if (mutation.type === 'attributes' && mutation.attributeName === 'class') {
                        const oldClassList = mutation.oldValue ? mutation.oldValue.split(/\s+/) : [];
                        const newClassList = this.className.split(/\s+/);
                        if (!newClassList.includes(className) && oldClassList.includes(className)) {
                            callback();
                        }
                    }
                });
            });
            observer.observe(this, { attributes: true, attributeOldValue: true, attributeFilter: ['class'] });
        };

        // Usage
        // document.body.onClassAdded('active-turn', function() {
        //     console.log('active-turn was added');
        // });
        // document.body.onClassRemoved('active-turn', function() {
        //     console.log('active-turn was removed');
        // });


        window.onload = function() {
            chosenFont = getCookie('fontPreference') || 'font-nothing-you-could-do'
            setCookie('fontPreference', chosenFont);
            document.body.classList.add(chosenFont);
            populateSelectWithFonts();
            document.querySelector('#selectFont').addEventListener('change', function(event) {
                const selectedClass = event.target.value;
                // First, remove any existing font class from the body
                document.body.classList.remove(...document.body.classList);
                // Then, add the new selected class
                document.body.classList.add(selectedClass);
                // Remember the setting
                setCookie('fontPreference', selectedClass);
            })

            // Recall player entries saved to cookie
            const savedEntries = getCookie('players');
            if (savedEntries) {
                players = JSON.parse(savedEntries);
                renderPlayers();
            }

            // rehydrate the current turn, if it was recorded
            const turnStarted = getCookie('turnStarted');
            if (turnStarted) {
                document.body.classList.add('active-turn');
            }
            const savedRound = getCookie('round');
            if (savedRound) {
                currentRound = parseInt(savedRound, 10);
                document.getElementById('roundCounter').textContent = 'Round ' + savedRound;
            }
            const savedTurn = getCookie('turn');
            if (savedTurn) {
                currentTurn = parseInt(savedTurn, 10);
                highlightCurrentTurn();
            }
            
            // set the state of the Previous buttton based on rehydrated round/turn state
            document.getElementById('prevTurn').disabled = (currentRound < 2 && currentTurn < 1);

            document.getElementById('startDictation').addEventListener('click', function() {
                // Create a new input element
                const input = document.createElement('input');
                input.type = 'text';
                input.className = 'speech-input'; // Set the class
                input.placeholder = '⇣ Dictate with voice-to-text ⇣'

                // Append to the speechInputs div
                document.getElementById('speechInputs').appendChild(input);

                // Focus the input
                input.focus();
            });

            let lastEntryWasKeyboard = false;
            // Event delegation: Attach listeners to the speechInputs container and delegate to children
            document.getElementById('speechInputs').addEventListener('focus', function(e) {
                if (e.target && e.target.classList.contains('speech-input')) {
                    console.log(e.type)
                    this.select()
                }
            })
            document.getElementById('speechInputs').addEventListener('input', function(e) {
                if (e.target && e.target.classList.contains('speech-input')) {
                    console.log(e.type)
                    if (!lastEntryWasKeyboard) {
                        parseAndAddEntries()
                        setTimeout(()=>{document.getElementById('startButton').focus()}, 1)
                    } else {
                        lastEntryWasKeyboard = false
                    }
                }
            })
            document.getElementById('speechInputs').addEventListener('keydown', function(e) {
                if (e.target && e.target.classList.contains('speech-input')) {
                    console.log(e.type)
                    if (e.key === 'Enter') {
                        parseAndAddEntries()
                        setTimeout(()=>{document.getElementById('startButton').focus()}, 1)
                    } else {
                        lastEntryWasKeyboard = true
                    }
                }
            })

            document.body.onClassAdded('active-turn', function() {
                console.log('active-turn was added');
                document.getElementById('prevTurn').disabled = true;
                document.getElementById('nextTurn').disabled = false;
                document.getElementById('startButton').disabled = true;
            });

            document.body.onClassRemoved('active-turn', function() {
                console.log('active-turn was removed');
                document.getElementById('prevTurn').disabled = true;
                document.getElementById('nextTurn').disabled = true;
                document.getElementById('startButton').disabled = false;
            });
        };
        function populateSelectWithFonts() {
            const fonts = [
                'Architects Daughter', 'Babylonica', 'Bilbo Swash Caps', 'Caveat', 'Comforter', 
                'Condiment', 'Dawning of a New Day', 'East Sea Dokdo', 'Fuggles',
                'Grape Nuts', 'Homemade Apple', 'Inspiration', 'Julee', 'Just Me Again Down Here', 'Kolker Brush',
                'La Belle Aurore', 'Liu Jian Mao Cao', 'Long Cang', 'Nanum Brush Script', 
                'Nothing You Could Do', 'Oooh Baby', 'Over the Rainbow', 'Permanent Marker', 'Qwitcher Grypen', 'Reenie Beanie', 
                'Rock Salt', 'Ruthie', 'Sassy Frass', 'Sedgwick Ave', 'Shalimar', 'Smooch', 'Splash', 'Square Peg',
                'Swanky and Moo Moo', 'Vujahday Script', 'Waiting for the Sunrise', 'Walter Turncoat', 'Whisper'
            ];

            const selectElement = document.querySelector('#selectFont');
            fonts.forEach(font => {
                const option = document.createElement('option');
                const val = 'font-' + font.toLowerCase().replace(/\s+/g, '-'); // Convert font name to classname format
                option.value = val;
                if (val == chosenFont) {
                    option.selected = true
                }
                option.textContent = font;
                selectElement.appendChild(option);
            });
        }

        function parseAndAddEntries() {
            // Get all input elements with the class 'speech-input'
            const inputs = document.querySelectorAll('.speech-input');
            
            // Map over each input to get its value and join them with spaces
            const joinedInput = Array.from(inputs).map(input => input.value).join(' ') + ' ';

            let convertedInput = processInput(joinedInput, numberMap);

            const regex = /([\w\s]+?)\s*?@ (-?\d+)/g;
            let matches;

            players = [];
            while ((matches = regex.exec(convertedInput)) !== null) {
                let name = matches[1].trim();
                let orderString = matches[2];

                let order;
                if (orderString && isNaN(orderString)) {
                    order = numberMap[orderString.toLowerCase()] || NaN;
                } else if(orderString && !isNaN(orderString)) {
                    order = parseInt(orderString, 10);
                } else {
                    order = NaN;  // default to NaN if orderString is not defined
                }

                // Capitalize the name
                name = name.split(" ").map(capitalize).join(" ");
                players.push({ name: name, order: order });
            }

            // Sorting and rendering the players
            players.sort((a, b) => b.order - a.order);
            renderPlayers();
            setCookie('players', JSON.stringify(players));
        }

        function processInput(input, numberMap) {
            console.log(input);

            // Remove punctuation
            input = input.replace(/[.,!?;:()]/g, '');

            // Replace the roll/role variations with the symbol "@"
            input = input.replace(/ (rolled|roll|role)( a| an| and)? /g, ' @ ');
            console.log(input);

            // Handle negative numbers in word format adjacent to "@"
            const negativeWordPattern = /@ (?:negative|-) (\w+|\d+)/g;
            input = input.replace(negativeWordPattern, (match, wordOrNum) => {
                if (numberMap[wordOrNum]) {
                    return '@ -' + numberMap[wordOrNum];
                } else {
                    return '@ -' + wordOrNum;
                }
            });
            console.log(input);
            
            // Handle negative numbers in digit format after "@"
            const negativePatternAfter = /@ negative (\d+)/g;
            input = input.replace(negativePatternAfter, (match, p1) => {
                return '@ -' + p1;
            });
            console.log(input);

            // Handle hyphenated numbers adjacent to "rolled" 
            for (const [word, number] of Object.entries(numberMap)) {
                if (!word.includes('-')) continue;

                let patternBefore = new RegExp(`\\b${word}(?= @)`, 'g');
                let patternAfter = new RegExp(`(?<=@ )${word}(?= )`, 'g');
                let patternAfterA = new RegExp(`(?<=@ a )${word}\\b`, 'g');
                let patternAfterAn = new RegExp(`(?<=@ an )${word}\\b`, 'g');
                let patternAfterAnd = new RegExp(`(?<=@ and )${word}\\b`, 'g');

                input = input.replace(patternBefore, `${number}`);
                input = input.replace(patternAfter, `${number}`);
                input = input.replace(patternAfterA, `${number}`);
                input = input.replace(patternAfterAn, `${number}`);
                input = input.replace(patternAfterAnd, `${number}`);
            }
            console.log(input);

            // Then handle non-hyphenated numbers adjacent to "rolled"
            for (const [word, number] of Object.entries(numberMap)) {
                if (word.includes('-')) continue;

                let patternBefore = new RegExp(`\\b${word}(?= @)`, 'g');
                let patternAfter = new RegExp(`(?<=@ )${word}(?= )`, 'g');
                let patternAfterA = new RegExp(`(?<=@ a )${word}\\b`, 'g');
                let patternAfterAn = new RegExp(`(?<=@ an )${word}\\b`, 'g');
                let patternAfterAnd = new RegExp(`(?<=@ and )${word}\\b`, 'g');

                input = input.replace(patternBefore, `${number}`);
                input = input.replace(patternAfter, `${number}`);
                input = input.replace(patternAfterA, `${number}`);
                input = input.replace(patternAfterAn, `${number}`);
                input = input.replace(patternAfterAnd, `${number}`);
            }
            console.log(input);

            return input;
        }

        function capitalize(word) {
            return word.charAt(0).toUpperCase() + word.slice(1).toLowerCase();
        }

        function startTurnCounter() {
            highlightCurrentTurn();
            document.body.classList.add('active-turn');
            setCookie('turnStarted', 'true');
        }

        function advanceTurn() {
            currentTurn = (currentTurn + 1) % players.length;
            setCookie('turn', currentTurn);

            // If it wraps back to the first player
            if (currentTurn == 0) {
                currentRound++;
                document.getElementById('roundCounter').textContent = 'Round ' + currentRound;
                setCookie('round', currentRound);
            }
            
            highlightCurrentTurn();

            document.getElementById('prevTurn').disabled = false;
        }

        function goBackOneTurn() {
            currentTurn--
            
            // If it wraps back to the last player
            if (currentTurn == -1) {
                currentTurn = players.length-1
                currentRound--

                // Reset if we went back to "round 0"
                if (currentRound == 0) {
                    currentRound = 1;
                    currentTurn = 0;
                    turnStarted = false;
                    setCookie('turnStarted', 'false');

                }
                document.getElementById('roundCounter').textContent = 'Round ' + currentRound;
                setCookie('round', currentRound)
            }

            highlightCurrentTurn();
            setCookie('turn', currentTurn);

            if (currentRound == 1 && currentTurn == 0) {
                document.getElementById('prevTurn').disabled = true;
            }
        }

        function clearAll() {
            players = [];
            currentTurn = 0;
            currentRound = 1;
            renderPlayers();
            document.body.classList.remove('active-turn');
            document.body.classList.remove('players-listed');

            // Clearing cookies
            document.cookie = "players=; expires=Thu, 01 Jan 1970 00:00:00 UTC; path=/;";
            document.cookie = "turn=; expires=Thu, 01 Jan 1970 00:00:00 UTC; path=/;";
            document.cookie = "round=; expires=Thu, 01 Jan 1970 00:00:00 UTC; path=/;";
            document.cookie = "turnStarted=; expires=Thu, 01 Jan 1970 00:00:00 UTC; path=/;";
            document.cookie = "fontPreference=; expires=Thu, 01 Jan 1970 00:00:00 UTC; path=/;";
        }

        function renderPlayers() {
            const list = document.getElementById('entries');
            list.innerHTML = '';
            for (let entry of players) {
                const li = document.createElement('li');
                
                const nameSpan = document.createElement('span');
                nameSpan.textContent = entry.name;
                nameSpan.onclick = function() {
                    makeEditable(nameSpan, entry, 'name');
                };
                
                const orderSpan = document.createElement('span');
                orderSpan.textContent = `${entry.order}`;
                orderSpan.onclick = function() {
                    makeEditable(orderSpan, entry, 'order', 'number');
                };
                
                li.appendChild(nameSpan);
                li.appendChild(orderSpan);
                list.appendChild(li);
            }
            document.body.classList.add('players-listed');
        }


        function makeEditable(element, entry, field, type) {
            const input = document.createElement('input')
            input.type = type
            if (type == 'number') {
                input.setAttribute("pattern", "[0-9]*")
            } else {
                input.setAttribute("autocapitalize", "words")
            }
            input.value = entry[field]
            
            // Handle "submit" when Enter key is pressed
            input.addEventListener('keydown', function(e) {
                if (e.key === 'Enter') {
                    handleEdit();
                }
            });

            // Handle "submit" when input loses focus
            input.addEventListener('focusout', handleEdit);

            function handleEdit() {
                entry[field] = field === 'order' ? parseInt(input.value, 10) : input.value;
                players.sort((a, b) => b.order - a.order); // Re-sorting on edit
                renderPlayers();
                setCookie('players', JSON.stringify(players));
            }

            element.replaceWith(input);
            input.select(); 
        }

        function highlightCurrentTurn() {
            const listItems = document.querySelectorAll('#entries li');
            listItems.forEach(li => li.classList.remove('highlighted'));
            if (listItems[currentTurn]) {
                listItems[currentTurn].classList.add('highlighted');
            }
        }

        function setCookie(name, value) {
            document.cookie = `${name}=${value};path=/`;
        }

        function getCookie(name) {
            const value = "; " + document.cookie;
            const parts = value.split("; " + name + "=");
            if (parts.length == 2) return parts.pop().split(";").shift();
        }
    </script>
    <!-- TODOs -->
    <!--
        1. add other commands to the dicatation input
        2. move buttons around
    -->
</body>
</html>
